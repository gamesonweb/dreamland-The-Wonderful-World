"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatethe_wonderful_world"]("main",{

/***/ "./src/entities/players/CameraController.ts":
/*!**************************************************!*\
  !*** ./src/entities/players/CameraController.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraController: () => (/* binding */ CameraController)\n/* harmony export */ });\n/* harmony import */ var _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core */ \"./node_modules/@babylonjs/core/index.js\");\n\nclass CameraController {\n    constructor(scene, canvas, target) {\n        // Camera parameters\n        this.distance = 4; // Distance from character\n        this.height = 1.5; // Height above character\n        this.yaw = 0; // Horizontal rotation (radians)\n        this.pitch = Math.PI / 6; // Vertical rotation (radians, ~30° upward)\n        this.smoothing = 0.1; // Smoothing factor (lower = smoother)\n        this.pitchMin = -Math.PI / 18; // ~ -10°\n        this.pitchMax = Math.PI / 3; // ~60°\n        // Mouse input\n        this.isMouseDown = false;\n        this.lastMouseX = 0;\n        this.lastMouseY = 0;\n        this.mouseSensitivity = 0.005; // Adjust for rotation speed\n        // Nouveaux paramètres\n        this.cameraLag = 0.1; // Retard de suivi (plus élevé = plus fluide)\n        this.lookAtOffset = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0); // Point de regard légèrement au-dessus du personnage\n        this.collisionRadius = 0.5; // Prévention des collisions avec les murs\n        this.currentRotation = 0; // Rotation actuelle pour l'interpolation\n        this.scene = scene;\n        this.canvas = canvas;\n        this.target = target;\n        // Create FreeCamera\n        this.camera = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.FreeCamera(\"thirdPersonCam\", _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), scene);\n        this.camera.fov = 0.8; // Field of view (radians)\n        this.scene.activeCamera = this.camera;\n        // Lock camera to prevent default Babylon.js input handling\n        this.camera.inputs.clear();\n        // Setup mouse input\n        this.setupInput();\n        // Initial camera position\n        this.updateCameraPosition(this.scene.getEngine().getDeltaTime() / 1000); // No smoothing for initial position\n        // Configurer la caméra pour le style Genshin\n        this.camera.fov = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Tools.ToRadians(70); // Champ de vision plus large\n        this.camera.minZ = 0.1;\n        this.camera.speed = 0; // Désactiver le déplacement clavier\n        // Activer le verrouillage du pointeur pour un contrôle fluide\n        this.setupPointerLock();\n    }\n    setupPointerLock() {\n        this.canvas.addEventListener(\"click\", () => {\n            if (!document.pointerLockElement) {\n                this.canvas.requestPointerLock = this.canvas.requestPointerLock;\n                this.canvas.requestPointerLock();\n            }\n        });\n        document.addEventListener(\"pointerlockchange\", this.handlePointerLockChange.bind(this));\n    }\n    handlePointerLockChange() {\n        if (document.pointerLockElement === this.canvas) {\n            this.isMouseDown = true;\n            this.canvas.addEventListener(\"mousemove\", this.handleMouseMove.bind(this));\n        }\n        else {\n            this.isMouseDown = false;\n            this.canvas.removeEventListener(\"mousemove\", this.handleMouseMove.bind(this));\n        }\n    }\n    handleMouseMove(e) {\n        if (!this.isMouseDown)\n            return;\n        const deltaX = e.movementX || 0;\n        const deltaY = e.movementY || 0;\n        // Rotation horizontale plus fluide\n        this.yaw -= deltaX * this.mouseSensitivity * 0.5;\n        // Rotation verticale avec limites avec un equivalent de Clamp \n        this.pitch = Math.max(this.pitchMin, Math.min(this.pitchMax, this.pitch + deltaY * this.mouseSensitivity * 0.5));\n    }\n    setupInput() {\n        // Mouse down to start rotating\n        this.canvas.addEventListener(\"mousedown\", (event) => {\n            if (event.button === 0) { // Left click\n                this.isMouseDown = true;\n                this.lastMouseX = event.clientX;\n                this.lastMouseY = event.clientY;\n            }\n        });\n        // Mouse up to stop rotating\n        this.canvas.addEventListener(\"mouseup\", () => {\n            this.isMouseDown = false;\n        });\n        // Mouse move to update yaw and pitch\n        this.canvas.addEventListener(\"mousemove\", (event) => {\n            if (this.isMouseDown) {\n                const deltaX = event.clientX - this.lastMouseX;\n                const deltaY = event.clientY - this.lastMouseY;\n                // Update yaw (horizontal) and pitch (vertical)\n                this.yaw -= deltaX * this.mouseSensitivity;\n                this.pitch += deltaY * this.mouseSensitivity;\n                // Clamp pitch to prevent flipping\n                this.pitch = Math.max(this.pitchMin, Math.min(this.pitchMax, this.pitch));\n                // Update last mouse position\n                this.lastMouseX = event.clientX;\n                this.lastMouseY = event.clientY;\n            }\n        });\n        // Prevent context menu on right-click (optional)\n        this.canvas.addEventListener(\"contextmenu\", (event) => event.preventDefault());\n    }\n    update(deltaTime) {\n        // Interpolation de la rotation pour plus de douceur\n        this.currentRotation = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Scalar.Lerp(this.currentRotation, this.yaw, 0.1);\n        // Mise à jour de la position avec retard\n        this.updateCameraPosition(deltaTime);\n    }\n    updateCameraPosition(deltaTime) {\n        // Calcul de la position idéale avec interpolation\n        const rotationMatrix = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Matrix.RotationYawPitchRoll(this.currentRotation, this.pitch, 0);\n        const offset = new _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, this.height, -this.distance);\n        const rotatedOffset = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3.TransformCoordinates(offset, rotationMatrix);\n        // Position cible avec lissage\n        const targetPosition = this.target.add(rotatedOffset);\n        const newPosition = _babylonjs_core__WEBPACK_IMPORTED_MODULE_0__.Vector3.Lerp(this.camera.position, targetPosition, this.cameraLag);\n        // Appliquer la position\n        this.camera.position = newPosition;\n        // Regarder vers le personnage avec un léger offset vertical\n        this.camera.setTarget(this.target.add(this.lookAtOffset));\n    }\n    getCamera() {\n        return this.camera;\n    }\n}\n\n\n//# sourceURL=webpack://the-wonderful-world/./src/entities/players/CameraController.ts?");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("04e98e89acf2a9a64a8d")
/******/ })();
/******/ 
/******/ }
);